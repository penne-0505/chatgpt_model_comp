**TL;DR**
オブジェクトストレージの整合性モデルは「データが“いつ”“どこで”同じ状態になるか」を決めるルールで、性能・可用性・コストに大きく影響する。

---

## 全体像

* **目的**: 分散環境で「書いた直後に読めるか」「一覧で揃うか」を保証しつつ、性能や価格とのバランスを取る。
* **主要モード**

  1. **強整合性 (Strong / Linearizable)** – 常に最新データが読める
  2. **結果整合性 (Eventual)** – いずれ最新になるが「いつ」とは限らない
  3. **可変整合性 (Tunable / Session / Causal など)** – アプリ要件に合わせ粒度指定
* **評価軸**

  * **整合速度**: 伝播に要する時間 (サブミリ秒～数秒)
  * **可用性**: 障害時の読み書き継続性
  * **コスト & パフォーマンス**: レプリカ数や同期頻度による

---

## 詳細

### 1. 強整合性

| 特徴                                               | 代表的な提供形態                                                                                                        |
| ------------------------------------------------ | --------------------------------------------------------------------------------------------------------------- |
| 書き込み完了＝全リージョンの最新状態確定。直後の `GET` や `LIST` でも必ず最新版。 | - **AWS S3** (2020/12 以降全リージョン) <br> - **Google Cloud Storage** (デフォルト) <br> - **オンプレ Ceph/RADOS** (sync write) |

* **メリット**: バッチ処理・データレイク・金融取引など“絶対に取り違え不可”なワークロード向き。
* **デメリット**: 書き込みレイテンシが長く、マルチリージョン構成ではコスト高。

### 2. 結果整合性

| 特徴                                          | 代表的な提供形態                                                                                                              |
| ------------------------------------------- | --------------------------------------------------------------------------------------------------------------------- |
| 書き込み完了直後は一部ノードが旧バージョンを返す可能性。時間経過か再試行で最新に収束。 | - **Azure Blob Storage**（一部操作） <br> - **DigitalOcean Spaces** / **Wasabi** <br> - 多くの自前 MinIO／Swift クラスタ（非同期レプリケーション） |

* **適用例**: 画像ホスティング・ログ保存など「多少古くても支障が小さい」シナリオ。
* **落とし穴**: オブジェクトの上書き(`PUT`)後すぐ `LIST` したら旧キーが残る、など。

### 3. 可変整合性モデル

| バリエーション                 | 例                                                     |
| ----------------------- | ----------------------------------------------------- |
| **Session Consistency** | 同一セッション内では強整合、跨ぐと結果整合 (例: AWS DynamoDB では読取り整合レベルを選択) |
| **Causal / Monotonic**  | 書込み順序のみ保証。SNS・チャット履歴で利用                               |
| **Tunable**             | Cassandra／ScyllaDB 形式。`R + W > N` で強整合を実現可能           |

* **意義**: SLA やコストを細かく最適化。
* **設計指針**: 「どの操作が遅れても許容できるか」をユースケース単位で定義する。

---

## まとめ

1. **整合性≠性能トレードオフ** – 速さ・可用性・コストのバランスを設計時に明示的に選ぶ。
2. **クラウド事業者の進化** – S3やGCSは強整合を標準化しつつ、ペイロード最適化でレイテンシを抑制。
3. **アプリレイヤで補完** – リトライ／バージョニング／Idempotent設計で残存リスクを吸収する。

---

### 整合性モード・整合速度・事例

| 整合性モード     | 整合速度 (目安) | 典型的事例                                    |
| ---------- | --------- | ---------------------------------------- |
| 強整合性       | ミリ秒～数百 ms | AWS S3, GCS, Ceph sync                   |
| 結果整合性      | 秒～数十秒     | Azure Blob (一部), Wasabi, 自前MinIO         |
| 可変 / セッション | アプリ設定次第   | DynamoDB (Read Consistency選択), Cassandra |
